# 单步训练模式修改说明

## 修改概述

已将原本的多步训练模式改为单步训练模式,主要修改了 `spiking_resnet.py` 中的前向传播逻辑。

## 主要修改

### 1. spiking_resnet.py - `_forward_impl` 方法

**原始代码（多步模式）:**
```python
def _forward_impl(self, x):
    x = self.conv1(x)
    x = self.bn1(x)
    x.unsqueeze_(0)
    x = x.repeat(self.T, 1, 1, 1, 1)  # 一次性复制T个时间步
    x = self.sn1(x)
    x = self.maxpool(x)
    x = self.layer1(x)
    x = self.layer2(x)
    x = self.layer3(x)
    x = self.layer4(x)
    x = self.avgpool(x)
    x = torch.flatten(x, 2)
    return self.fc(x.mean(dim=0))
```

**修改后（单步模式）:**
```python
def _forward_impl(self, x):
    # 单步训练模式：手动循环时间步
    x = self.conv1(x)
    x = self.bn1(x)
    
    # 逐时间步进行前向传播
    for t in range(self.T):
        # 在每个时间步使用相同的输入
        x_t = x.unsqueeze(0)  # [1, N, C, H, W]
        
        x_t = self.sn1(x_t)
        x_t = self.maxpool(x_t)
        x_t = self.layer1(x_t)
        x_t = self.layer2(x_t)
        x_t = self.layer3(x_t)
        x_t = self.layer4(x_t)
        x_t = self.avgpool(x_t)
        x_t = torch.flatten(x_t, 2)
        
        # 去掉时间维度 [1, N, Features] -> [N, Features]
        x_t = x_t.squeeze(0)
        out_t = self.fc(x_t)
        
        # 累加每个时间步的输出
        if t == 0:
            out_spikes_counter = out_t
        else:
            out_spikes_counter = out_spikes_counter + out_t
    
    # 返回平均输出
    return out_spikes_counter / self.T
```

## 关键变化

1. **从批量处理改为逐步循环**: 
   - 原本: `x.repeat(self.T, ...)` 一次性创建T个时间步的数据
   - 现在: `for t in range(self.T)` 逐个时间步处理

2. **显存使用优化**:
   - 原本: 同时处理 shape=[T, N, C, H, W] 的数据
   - 现在: 每次只处理 shape=[1, N, C, H, W] 的数据
   - 显存占用理论上可减少约 T 倍

3. **输出累加**:
   - 在每个时间步累加输出
   - 最后除以 T 得到平均发放率

## 优势

1. **节省显存**: 每次只处理一个时间步,显存占用大幅减少
2. **适合长时间步**: 当T值很大时,单步模式可以避免显存溢出
3. **保持兼容**: 训练和评估函数无需修改,使用相同的接口

## 劣势

1. **速度可能变慢**: 逐步循环无法充分利用GPU并行计算
2. **反向传播开销**: 梯度计算可能会增加一些开销

## 训练和评估

训练脚本 `train.py` 中的 `train_one_epoch` 和 `evaluate` 函数无需修改,它们会自动使用新的单步前向传播逻辑。

神经元状态仍然通过 `functional.reset_net(model)` 在每个batch后重置。

## 使用方法

保持原有的训练命令不变,例如:
```bash
python train.py --model spiking_resnet18 --T 4 --batch-size 16 --lr 0.1
```

模型会自动使用单步循环进行T=4个时间步的训练。
